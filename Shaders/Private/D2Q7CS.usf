//// MyTest.usf
 
//// Simple pass-through vertex shader
//void MainVS(
// in float4 InPosition : ATTRIBUTE0,
// out float4 Output : SV_POSITION
//)
//{
//    Output = InPosition;
//}
 
//// Simple solid color pixel shader
//float4 MyColor;
//float4 MainPS() : SV_Target0
//{
//    return MyColor;
//}

#include "/Engine/Public/Platform.ush"

//Nx = 400    // resolution x-dir
//Ny = 100    // resolution y-dir
float Rho0; // = 100; // average density
float Tau; // = 0.6; // collision timescale

int IsInit; // = 1;  // bool не работает на уровне C++.
int Nx;
int Ny;

Texture2D<float> F_in;     // F with current t
RWTexture2D<float> F_out;  // t + 1

static int NL = 9;
//static int idxs[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };
static int cxs[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1 };
static int cys[] = { 0, 1, 1, 0, -1, -1, -1, 0, 1 };
static float weights[] = { 4.0/9.0, 1.0/9.0, 1.0/36.0, 1.0/9.0, 1.0/36.0, 1.0/9.0, 1.0/36.0, 1.0/9.0, 1.0/36.0 };
static const float PI = 3.14159265f;

SamplerState F_SamplerState;

float getLocalRho(int x_tex, int y_tex, int n_d)
{
    float rho = 0;
    for (int i = 0; i < n_d; i++)
    {
        rho += F_out[float2(x_tex, y_tex + i)]; // WARN! using F_out! -> F!
    }
    
    return rho;
}

void initArray(int x, int y, int x_tex, int y_tex)
{
    //Fill init velocities:
    for (int i = 0; i < NL; i++)
    {
        F_out[float2(x_tex, y_tex + i)] = 1;
    }
        // TODO: F_out[x][y] += rand;   - (добавить флуктуации)
        
        
        // Задаем направление потока вправо:
    F_out[float2(x_tex, y_tex + 3)] += 2 * (1 + 0.2 * cos(2 * PI * x / Nx * 4));
        
    
    
    // Нормализуем распределение направлений частиц по глобальной плотности:
    float rho = 0; // текущая локальная плотность.
    for (i = 0; i < NL; i++)
    {
        rho += F_out[float2(x_tex, y_tex + i)];
    }
    for (i = 0; i < NL; i++)
    {
        F_out[float2(x_tex, y_tex + i)] *= Rho0 / rho;
    }
        
        
        // Set cylinder: TODO: set boundaries outside.
    if ((pow((x - Nx / 4), 2) + pow((y - Ny / 2), 2)) < pow((Ny / 4), 2))   //  (x > 0 && x < 3 && y > -1 && y < 2)
    {
        for (int i = 0; i < NL; i++)
        {
            F_out[float2(x_tex, y_tex + i)] = 0;
        }
    }
}

void initTestArray(int x, int y, int x_tex, int y_tex)
{
    F_out[float2(x_tex, y_tex)] = -82772.8438;
    F_out[float2(x_tex, y_tex + 1)] = -20693.1875;
    F_out[float2(x_tex, y_tex + 2)] = 10585.1973;
    F_out[float2(x_tex, y_tex + 3)] = 42340.7734;
    F_out[float2(x_tex, y_tex + 4)] = 10585.2070;
    F_out[float2(x_tex, y_tex + 5)] = -20693.1875;
    F_out[float2(x_tex, y_tex + 6)] = 9522.18457;
    F_out[float2(x_tex, y_tex + 7)] = 38088.6602;
    F_out[float2(x_tex, y_tex + 8)] = 9522.19531;

}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void Main(uint3 DTid : SV_DispatchThreadID)
{
    // Координаты рассчетной сетки:
    int x = DTid.x;
    int y = DTid.y;
    
    // координаты для F_out:
    int x_out = DTid.x;
    int y_out = DTid.y * 9;    // масштабируем Y {0..100} -> Y {0..900}, т.к. в одном узле сетки надо хранить 9 значений скорости (для каждого нарпавления).
    //uint v_id = DTid.y % 9; // остаток от деления?
    
    if (IsInit != 0)
    {
        //initArray(x, y, x_out, y_out);
        //initTestArray(x, y, x_out, y_out);
    }
    
    // DRIFT:
    //// Drift particles (with sampling): - TODO: test sampling vs indexing vs lerp perfomance.
    //float2 uv;
    //uv.x = (x_out - 0.5) / Nx;
    //uv.y = (y_out + 3 + 0.5) / (Ny * 9);
    ////float prob = F_in.Sample(samplerState, uv);
    //F_out[float2(x_out, y_out + 3)] = F_in.SampleLevel(F_SamplerState, uv, 0);
    
    
    float F[9]; // TODO: перенести в регистровую или разделяемую память.
    for (int i = 0; i < NL; i++)
    {
        F[i] = F_in[float2(x_out, y_out + i)];
    }
    //F[0] = F_in[float2(x_out, y_out)];
    
    // Drift particles to neighbours (with indexing):
    for (int neighbour_id = 0; neighbour_id < NL; neighbour_id++)
    {
        int neighbour_x = x - cxs[neighbour_id];
        int neighbour_y = y - cys[neighbour_id];

        // замыкаем границы (аналог np.roll):
        if ((neighbour_x == -1) || (neighbour_x == Nx))
        {
            neighbour_x = abs(abs(neighbour_x) - Nx);
        }
        if ((neighbour_y == -1) || (neighbour_y == Ny))
        {
            neighbour_y = abs(abs(neighbour_y) - Ny);
        }

        int neighbour_y_out = neighbour_y * 9;
        
        //F_out[float2(x_out, y_out + neighbour_id)] = F_in[float2(neighbour_x, neighbour_y_out + neighbour_id)];
        F[neighbour_id] = F_in[float2(neighbour_x, neighbour_y_out + neighbour_id)];
    }
    
    float F_bound_temp[9];
    // Check is cylinder and reflect: TODO: set boundaries outside.
    if ((pow((x - Nx / 4), 2) + pow((y - Ny / 2), 2)) < pow((Ny / 4), 2))
    {
        F_bound_temp[0] = F[0];
        F_bound_temp[1] = F[5];
        F_bound_temp[2] = F[6];
        F_bound_temp[3] = F[7];
        F_bound_temp[4] = F[8];
        F_bound_temp[5] = F[1];
        F_bound_temp[6] = F[2];
        F_bound_temp[7] = F[3];
        F_bound_temp[8] = F[4];
        F = F_bound_temp;
    }
    else // if it isn't boundary.
    {
        //float rho = getLocalRho(x_out, y_out, NL);
        float rho = 0;
        for (int i = 0; i < NL; i++)
        {
            rho += F[i];
        }
        float ux = 0;
        float uy = 0;
        for (int i = 0; i < NL; i++)
        {
            ux += F[i] * cxs[i];
            uy += F[i] * cys[i];
        }
        ux /= rho;
        uy /= rho;
    
        //COLLISION:
        float Feq[9];
        for (i = 0; i < NL; i++)
        {
            Feq[i] = rho * weights[i] * (1 + 3 * (cxs[i] * ux + cys[i] * uy) +
                                   9 * pow(cxs[i] * ux + cys[i] * uy, 2) / 2 -
                                   3 * (pow(ux, 2) + pow(uy, 2)) / 2);
            F[i] += -(1.0 / Tau) * (F[i] - Feq[i]);
        }
    
        //boundary here?
    }
    
        
    
    // OUTPUT:
    for (int i = 0; i < NL; i++)
    {
        F_out[float2(x_out, y_out + i)] = F[i];
    }
    
    
    
    
    
    
    
    
    
    
    
    
    //float output = DTid.xy;
    //float4 tex = F_in[DTid.xy];
    //if (tex.x < 1)
    //{
    //    tex.xyz += 0.01;
    //}
    //else
    //{
    //    tex.xyz = 0;
    //}
    
    //F_out[DTid.xy] = tex;
}
