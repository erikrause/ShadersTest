#include "/Engine/Public/Platform.ush"
#include "D2Q9CS-constants.usf"
//SamplerState F_SamplerState;
Texture2D<float2> U;
Texture2D<float2> Pos_in;
RWTexture2D<float2> Pos_out;

int Nx;
int Ny;
static const float timeScale = 1;
int Iteration;


// Замкнуть пространство на противоположные грани.
float2 closeField(float2 particle)
{
    float2 newParticle = float2(particle);
    
    if ((particle.x < 0) || (particle.x >= Nx))
    {
        newParticle.x = abs(abs(newParticle.x) - Nx);
    }
    if ((particle.y < 0) || (particle.y >= Ny))
    {
        newParticle.y = abs(abs(newParticle.y) - Ny);
    }
    
    return newParticle;
}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void Main(uint3 DTid : SV_DispatchThreadID)
{  
    // Init local variables:
    uint i, j, k = 0; // just iterator;
    
    float2 pos = Pos_in[DTid.xy];
    // Определяем нижнюю и верхнюю границу:
    int2 lower_lattice_neighbour = floor(pos);
    int2 upper_lattice_neighbour = ceil(pos);
    // Замыкаем пространство:
    int2 closed_lower_lattice_neigbour = closeField(lower_lattice_neighbour);
    int2 closed_upper_lattice_neigbour = closeField(upper_lattice_neighbour);
    
    // Linear interpolation:
    //// Соседи итерируются в цикле:
    //int3 current_lattice_neighbour;
    //int3 current_closed_lattice_neighbour;
    
    //#define lower lower_lattice_neighbour
    //#define upper upper_lattice_neighbour
    //#define closed_lower closed_lower_lattice_neigbour
    //#define closed_upper closed_upper_lattice_neigbour
    //#define current current_lattice_neighbour
    //#define current_closed current_closed_lattice_neighbour
    
    ///// TRILINEAR INTERPOLATION:
    //float s; // for lerp.
    //float2x3 u_x;
    //float2 xs;
    
    ////for (current.x; current.x <= upper.x; current.x++)
    //for (i = 0; i < 2; i++)
    //{
    //    float2x3 u_y;
    //    float2 ys;
        
    //    //for (current.y; current.y <= upper.y; current.y++)
    //    for (j = 0; j < 2; j++)
    //    {
    //        float2x3 u_z;
    //        float2 zs;
            
    //        //for (current.z; current.z <= upper.z; current.z++)
    //        for (k = 0; k < 2; k++)
    //        {
    //            current = lower + (upper - lower) * int3(i, j, k);
    //            current_closed = closed_lower + (closed_upper - closed_lower) * int3(i, j, k);
    //            // Координаты 3D данных, хранящиеся в 2D текстуре U.
    //            uint x_tex = current_closed.x + current_closed.z * Nx;
    //            uint y_tex = current_closed.y;
                
    //            float3 u = U[uint2(x_tex, y_tex)];
    //            u_z[k] = u;
    //            zs[k] = current.z;
    //        }
            
    //        s = (zs[1] - pos.z) / (zs[1] - zs[0]);
    //        u_y[j] = lerp(u_z[0], u_z[1], s); //(z2 - pos.z) / (z2 - z1));
    //        ys[j] = current.y;
    //    }
        
    //    s = (ys[1] - pos.y) / (ys[1] - ys[0]);
    //    u_x[i] = lerp(u_y[0], u_y[1], s);
    //    xs[i] = current.x;

    //    //int3 e = int3(cxs[i], cys[i], czs[i]);  // смещение к соседу.
    //    //int3 neigbour = 0;
    //}
    
    //s = (xs[1] - pos.x) / (xs[1] - xs[0]);
    //float3 interpolated_u = lerp(u_x[0], u_x[1], s);
    
    // Координаты 3D данных, хранящиеся в 2D текстуре U.
    uint x_tex = closed_lower_lattice_neigbour.x; // + closed_lower_lattice_neigbour.z * Nx;
    uint y_tex = closed_lower_lattice_neigbour.y;
    float2 u = U[uint2(x_tex, y_tex)];
    float2 newPos = closeField(pos + u);
    
    Pos_out[DTid.xy] = newPos;
    
    if (Iteration == 0)
    {
        //pos.z = DTid.x / (Nx * Ny);
        //uint tempX = DTid.x - (pos.z * Nx * Ny);
        pos.y = DTid.x / Nx;
        pos.x = DTid.x % Nx;
        Pos_out[DTid.xy] = pos;
    }
    
    //TODO: make closed position.
    
    
        //float3 u = ;
    
    //normalize(u);   // TEST! TODO: check time step.
    
    //Pos_out[DTid.xy] = pos + u;
}