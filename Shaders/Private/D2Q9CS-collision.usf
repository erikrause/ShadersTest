#include "/Engine/Public/Platform.ush"

static float Tau = 1.6; // collision timescale

Texture2D<float> F_in; // F with current t
RWTexture2D<float> F_out; // t + 1
RWTexture2D<float2> U;
int Iteration;
int Nx;
int Ny;
StructuredBuffer<int> PorousData;
static int cxs[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1 };
static int cys[] = { 0, 1, 1, 0, -1, -1, -1, 0, 1 };
static float weights[] = { 4.0 / 9.0, 1.0 / 9.0, 1.0 / 36.0, 1.0 / 9.0, 1.0 / 36.0, 1.0 / 9.0, 1.0 / 36.0, 1.0 / 9.0, 1.0 / 36.0 };
static const int Q = 9; // number of directions.

static const float PI = 3.14159265f;

bool isBoundary(int x, int y)
{
    //return PorousData[x + y * Nx] == 0;
    return ((pow((x - Nx / 4), 2) + pow((y - Ny / 2), 2)) < pow((Ny / 4), 2));
}

float getLocalRho(float f[Q])
{
    float rho = 0;
    for (int i = 0; i < Q; i++)
    {
        rho += f[i];
    }
    
    return rho;
}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void Main(uint3 DTid : SV_DispatchThreadID)
{
    // Координаты рассчетной сетки:
    int x = DTid.x;
    int y = DTid.y;
    
    // координаты для F_out:
    int x_out = DTid.x;
    int y_out = DTid.y * 9;
    
    float2 u = float2(0, 0);
    
    float F[Q];
    for (int i = 0; i < Q; i++)
    {
        F[i] = F_in[float2(x_out, y_out + i)];
    }
    
    if (!isBoundary(x, y))
    {
        float rho = getLocalRho(F);

        for (int i = 0; i < Q; i++)
        {
            u.x += F[i] * cxs[i];
            u.y += F[i] * cys[i];
        }
        u.x /= rho;
        u.y /= rho;
            
        float Feq[Q];
        float2 unit = float2(1, 1); // единичный вектор.
        for (i = 0; i < Q; i++)
        {
            float2 e = float2(cxs[i], cys[i]); // lattice direction.
            
            Feq[i] = rho * weights[i] * (1 + 3 * dot(e * u, unit) + //(cxs[i] * u.x + cys[i] * u.y) +
                                   9 * pow(dot(e * u, unit), 2) / 2 -
                                   3 * dot(pow(u, 2), unit) / 2);
            F[i] += -(1.0 / Tau) * (F[i] - Feq[i]);
        }
    }
    
    // F OUTPUT:
    for (int i = 0; i < Q; i++)
    {
        if (Iteration > 0)
        {
            F_out[float2(x_out, y_out + i)] = F[i];
        }
    }
    
    // U OUTPUT:
    U[float2(x, y)] = u;
}
    

