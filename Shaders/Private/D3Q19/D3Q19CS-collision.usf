#include "/Engine/Public/Platform.ush"

#include "D3Q19CS-constants.usf"

static float Tau = 1.6;
int Iteration;
int Nx;
int Ny;
int Nz;

Texture2D<float> F_in;     // F with current t
RWTexture2D<float> F_out;  // t + 1
RWTexture2D<float3> U;
StructuredBuffer<int> PorousData;

bool isBoundary(int x, int y, int z)
{
    return PorousData[x + y * Nx + z * Nx * Ny] == 0;
}

float getLocalRho(float f[Q])
{
    float rho = 0;
    for (int i = 0; i < Q; i++)
    {
        rho += f[i];
    }
    
    return rho;
}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void Main(uint3 DTid : SV_DispatchThreadID)
{
    // INIT:
    int i; // for iterator.
    // Координаты рассчетной сетки LBM:
    // поскольку текстура RenderTarget двумерная, то в измерениях текстуры x хранятся несколько измерений массива LBM:
    // - в X текстуры: X и Z пространства узлов;
    // - в Y текстуры: Y пространства узлов и Q направлений скоростей скоростей каждого узла.
    const int x = DTid.x % Nx;
    const int y = DTid.y;
    const int z = DTid.x / Nx;
    
    // Текстурные координаты (2D): в одном потоке мы обрабатываем все направления скоростей, поэтому расширяем "y" в тестуре.
    const int x_tex = DTid.x;
    const int y_tex = DTid.y * Q; // масштабируем Y {0..100} -> Y {0..900}, т.к. в одном узле сетки надо хранить 19 значений скорости (для каждого нарпавления).
    
    float3 u = float3(0, 0, 0);
        
    float f[Q]; // TODO: перенести в регистровую или разделяемую память.
    for (i = 0; i < Q; i++)
    {
        f[i] = F_in[float2(x_tex, y_tex + i)];
    }
    
    
    //COLLISION:
    if (!isBoundary(x, y, z)) //((pow((x - Nx / 4), 2) + pow((y - Ny / 2), 2)) < pow((Ny / 4), 2))
    {
        float rho = getLocalRho(f);
        
        for (i = 0; i < Q; i++)
        {
            float3 e = float3(cxs[i], cys[i], czs[i]);
            u += f[i] * e;
        }
        u /= rho;
    
        
        float f_eq[Q];
        float3 unit = float3(1, 1, 1); // единичный вектор.
        for (i = 0; i < Q; i++)
        {
            float3 e = float3(cxs[i], cys[i], czs[i]); // lattice direction.

            f_eq[i] = rho * weights[i] * (1 + 3 * dot(e * u, unit) +
                                   9 * pow(dot(e * u, unit), 2) / 2 -
                                   3 * dot(pow(u, 2), unit) / 2); // TODO: test 3D.
            f[i] += -(1.0 / Tau) * (f[i] - f_eq[i]);
        }
    }
        
    
    // F OUTPUT:
    for (i = 0; i < Q; i++)
    {
        if (Iteration > 0)
        {
            F_out[float2(x_tex, y_tex + i)] = f[i];
        }
    }
    
    // U OUTPUT:
    U[float2(x_tex, y)] = u;
    
    
    // VORTICITY:
    //Vorticity = 
    //vorticity = (np.roll(ux, -1, axis=0) - np.roll(ux, 1, axis=0)) - (np.roll(uy, -1, axis=1) - np.roll(uy, 1, axis=1))
}
