#include "/Engine/Public/Platform.ush"

static float Tau = 1.6; // collision timescale

StructuredBuffer<int> PorousData; //[2048]; //[40000];

int Iteration;
int Nx;
int Ny;
int Nz;

Texture2D<float> F_in;     // F with current t
RWTexture2D<float> F_out;  // t + 1
RWTexture2D<float3> U;

static const int Q = 19;
////static int idxs[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };  // не используетс€.
//static int cxs[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1 };
//static int cys[] = { 0, 1, 1, 0, -1, -1, -1, 0, 1 };
//static int inverse_indexes[] = { 0, 5, 6, 7, 8, 1, 2, 3, 4 };
//static float weights[] = { 4.0 / 9.0, 1.0 / 9.0, 1.0 / 36.0, 1.0 / 9.0, 1.0 / 36.0, 1.0 / 9.0, 1.0 / 36.0, 1.0 / 9.0, 1.0 / 36.0 };

// INDEXES:          0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18.
static int cxs[] = { 0,  1, -1,  0,  0,  0,  0,  1, -1,  1, -1,  1, -1,  1, -1,  0,  0,  0,  0 };
static int cys[] = { 0,  0,  0,  1, -1,  0,  0,  1, -1, -1,  1,  0,  0,  0,  0,  1, -1,  1, -1 };
static int czs[] = { 0,  0,  0,  0,  0,  1, -1,  0,  0,  0,  0,  1, -1, -1,  1,  1, -1, -1,  1 };
static int inverse_indexes[] =  
                   { 0,  2,  1,  4,  3,  6,  5,  8,  7, 10,  9, 12, 11, 14, 13, 16, 15, 18, 17 };

static float weights[] =
{
    1.0 / 3.0,
    1.0 / 18.0, 1.0 / 18.0, 1.0 / 18.0, 1.0 / 18.0, 1.0 / 18.0, 1.0 / 18.0,
    1.0 / 36.0, 1.0 / 36.0, 1.0 / 36.0, 1.0 / 36.0, 1.0 / 36.0, 1.0 / 36.0, 1.0 / 36.0, 1.0 / 36.0, 1.0 / 36.0, 1.0 / 36.0, 1.0 / 36.0, 1.0 / 36.0
};

static const float PI = 3.14159265f;

bool isBoundary(int x, int y, int z)
{
    return PorousData[x + y * Nx + z * Nx * Ny] == 0;
}

float getLocalRho(float f[Q])
{
    float rho = 0;
    for (int i = 0; i < Q; i++)
    {
        rho += f[i];
    }
    
    return rho;
}

[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void Main(uint3 DTid : SV_DispatchThreadID)
{
    //  оординаты рассчетной сетки LBM:
    // поскольку текстура RenderTarget двумерна€, то в измерени€х текстуры x хран€тс€ несколько измерений массива LBM:
    // - в X текстуры: X и Z пространства узлов;
    // - в Y текстуры: Y пространства узлов и Q направлений скоростей скоростей каждого узла.
    int x = DTid.x % Nz;
    int y = DTid.y;
    int z = DTid.x / Nz;
    
    // “екстурные координаты (2D): в одном потоке мы обрабатываем все направлени€ скоростей, поэтому расшир€ем y в тестуре.
    int x_out = DTid.x;
    int y_out = DTid.y * Q;    // масштабируем Y {0..100} -> Y {0..900}, т.к. в одном узле сетки надо хранить 19 значений скорости (дл€ каждого нарпавлени€).
    
    float3 u = float3(0, 0, 0);
    
    float F[Q]; // TODO: перенести в регистровую или раздел€емую пам€ть.
    for (int i = 0; i < Q; i++)
    {
        F[i] = F_in[float2(x_out, y_out + i)];
    }
    
    if (!isBoundary(x, y, z)) //((pow((x - Nx / 4), 2) + pow((y - Ny / 2), 2)) < pow((Ny / 4), 2))
    {
        float rho = getLocalRho(F);
        
        for (int i = 0; i < Q; i++)
        {
            // TODO: объединить в векторную операцию дл€ оптимизации.
            // ƒл€ суммировани€ компонентов дл€ Feq можно использовать dot product: float sum = dot(test, float3(1, 1, 1));
            u.x += F[i] * cxs[i];
            u.y += F[i] * cys[i];
            u.z += F[i] * czs[i];
        }
        u.x /= rho;
        u.y /= rho;
        u.z /= rho;
    
        //COLLISION:
        float Feq[Q];
        float3 unit = float3(1, 1, 1); // единичный вектор.
        for (i = 0; i < Q; i++)
        {
            float3 e = float3(cxs[i], cys[i], czs[i]); // lattice direction.
            
            //Feq[i] = rho * weights[i] * (1 + 3 * (cxs[i] * ux + cys[i] * uy) +
            //                       9 * pow(cxs[i] * ux + cys[i] * uy, 2) / 2 -
            //                       3 * (pow(ux, 2) + pow(uy, 2)) / 2);
            Feq[i] = rho * weights[i] * (1 + 3 * dot(e * u, unit) +
                                   9 * pow(dot(e * u, unit), 2) / 2 -
                                   3 * dot(pow(u, 2), unit) / 2); // TODO: test 3D.
            F[i] += -(1.0 / Tau) * (F[i] - Feq[i]);
        }
    
        //boundary here?
    }
        
    
    // F OUTPUT:
    for (int i = 0; i < Q; i++)
    {
        if (Iteration > 0)
        {
            F_out[float2(x_out, y_out + i)] = F[i];
        }
    }
    
    // U OUTPUT:
    U[float2(x_out, y)] = u;
    
    
    //// TEST POROUS OUTPUT:
    //int value = PorousData[x + y * Nx];
    //U[float2(x_out, y)] = float3(value, 0, 0); // test porous data out.
    
    
    // VORTICITY:
    //Vorticity = 
    //vorticity = (np.roll(ux, -1, axis=0) - np.roll(ux, 1, axis=0)) - (np.roll(uy, -1, axis=1) - np.roll(uy, 1, axis=1))
    
    
    
    
    
    
    
    
    
    
    
    
    //float output = DTid.xy;
    //float4 tex = F_in[DTid.xy];
    //if (tex.x < 1)
    //{
    //    tex.xyz += 0.01;
    //}
    //else
    //{
    //    tex.xyz = 0;
    //}
    
    //F_out[DTid.xy] = tex;
}
